import re
from .rules_base import pick_new_no, pick_old_no, parse_date, normalize_text

def extract_form_9(lines: list) -> dict:
    blocks = [ln for ln in lines if ln.strip()]
    text = normalize_text("\n".join(blocks))
    fields = {
        "doc_type": "FORM_9",
        "entity_name": None,
        "business_type": "Sdn. Bhd. (Private Limited)",
        "registration_number_new": pick_new_no(text),
        "registration_number_old": pick_old_no(text),
        "incorporation_or_registration_date": None,
        "valid_until": None,
        "registered_address": None,
        "branch_addresses": [],
        "issue_place": None,
        "issue_date": None,
        "signing_officer": None
    }

    # Company name appears prominently after "This is to certify that"
    for i, ln in enumerate(blocks):
        if "certify that" in ln.lower():
            # Check if name is on the same line
            parts = ln.split("certify that", 1) # case-insensitive split approx
            if len(parts) == 1: # try matching case-insensitive
                lower_ln = ln.lower()
                idx = lower_ln.find("certify that")
                if idx != -1:
                    candidate = ln[idx + len("certify that"):].strip()
                else:
                    candidate = ""
            else:
                 candidate = parts[1].strip()

            # If candidate is empty or just punctuation, look at next line
            if not candidate or len(candidate) < 3:
                j = i+1
                while j < len(blocks) and not blocks[j].strip():
                    j += 1
                if j < len(blocks): candidate = blocks[j].strip()
            
            if candidate:
                # Cleanup: remove registration numbers if they were captured in the name line
                if fields["registration_number_new"]:
                    candidate = candidate.replace(fields["registration_number_new"], "")
                if fields["registration_number_old"]:
                    candidate = candidate.replace(fields["registration_number_old"], "")
                
                # Remove parens wrapping the old number if they were left behind "()" or "(-)"
                candidate = candidate.replace("()", "").replace("(-)", "")
                
                fields["entity_name"] = candidate.strip(" ,.-")
            break
    if not fields["entity_name"]:
        exclusions = ["COMPANIES ACT", "CERTIFICATE OF INCORPORATION", "MALAYSIA", "SECTION 17", "FORM 9", "PRIVATE COMPANY", "LIMITED BY SHARES"]
        
        # Prioritize lines ending with SDN. BHD. / BHD. / BERHAD / SDNBHD
        priority_caps = [ln for ln in blocks if (
            ln.strip().upper().endswith("SDN. BHD.") or 
            ln.strip().upper().endswith("BERHAD") or 
            ln.strip().upper().endswith("BHD.") or
            ln.strip().upper().endswith("SDNBHD")
        ) and len(ln.strip()) > 5]
        
        if priority_caps:
            fields["entity_name"] = priority_caps[0]
        else:
            caps = [ln for ln in blocks if ln.strip().isupper() and len(ln.strip()) > 5 and not any(ex in ln.upper() for ex in exclusions)]
            fields["entity_name"] = sorted(caps, key=len, reverse=True)[0] if caps else None

    for i, ln in enumerate(blocks):
        low = ln.lower()
        if "on and from the" in low or "incorporated under" in low:
            fields["incorporation_or_registration_date"] = parse_date(ln)
        if low.startswith("dated at"):
            fields["issue_date"] = parse_date(ln)
            parts = ln.split(" ", 3)
            if len(parts) >= 3: fields["issue_place"] = parts[2].strip(",.")
        
        # Address extraction
        if "registered office at" in low:
            addr_parts = []
            if " at" in ln:
                remainder = ln.split(" at", 1)[-1].strip(" :-")
                if remainder: addr_parts.append(remainder)
            
            # Capture subsequent lines
            j = i + 1
            while j < len(blocks):
                next_ln = blocks[j].strip()
                next_low = next_ln.lower()
                
                if "dated at" in next_low: break
                if "registrar of companies" in next_low: break
                if "scan to verify" in next_low: break
                
                addr_parts.append(next_ln)
                j += 1
            
            if addr_parts:
                fields["registered_address"] = ", ".join(addr_parts)

        if "registrar of companies" in low:
            # Look backwards for the name
            found_name = False
            for k in range(i - 1, -1, -1):
                prev = blocks[k].strip()
                prev_low = prev.lower()
                
                # Stop if we hit the date line or certification line
                if "dated at" in prev_low:
                    break
                if "certify that" in prev_low:
                    break
                    
                # Skip short lines
                if len(prev) < 3:
                    continue
                
                # Skip known noise
                if prev.upper() in ["SSM", "MPM", "ER", "RE", "PRNT", "PRINT", "WDS", "WBS"]:
                    continue
                    
                # Skip lines that look like dates
                if parse_date(prev):
                    continue
                
                # Skip lines that look like serial numbers (many digits) or purely alphanumeric codes
                digit_count = sum(c.isdigit() for c in prev)
                if digit_count > 3:
                    continue
                
                # If we passed all checks, this is likely the name
                fields["signing_officer"] = prev
                found_name = True
                break
            
            # Fallback to current line if nothing found above
            if not found_name and not fields["signing_officer"]:
                fields["signing_officer"] = ln.strip()

    if not fields["registration_number_new"]:
         # Fallback: look for 12-digit number starting with 19 or 20 anywhere
         matches = re.findall(r"\b(19|20)\d{10}\b", text)
         if matches:
             # re.findall returns groups if present, so matches might be ['19', '20'] if groups used?
             # My regex has group (19|20). 
             # Better use simple search
             pass
         
         # Re-scan with simpler regex
         m_simple = re.search(r"\b((?:19|20)\d{10})\b", text)
         if m_simple:
             fields["registration_number_new"] = m_simple.group(1)

    return fields
